

import { JsonDecoder } from "ts.data.json";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: websocket/v1/websocket.proto
/* eslint-disable */
import { type TokenUpdate, TokenUpdateDecoder } from "../payload/client/v1/client";
import { type ImageList, type ImageProcessed, ImageListDecoder, ImageProcessedDecoder } from "../payload/server/v1/server";
export const protobufPackage = "faceblur.websocket.v1";
export enum ServerMessageType {
    SERVER_MESSAGE_TYPE_UNSPECIFIED = 0,
    SERVER_MESSAGE_TYPE_IMAGE_LIST = 1,
    SERVER_MESSAGE_TYPE_IMAGE_PROCESSED = 2,
    UNRECOGNIZED = -1
}
export enum ClientMessageType {
    CLIENT_MESSAGE_TYPE_UNSPECIFIED = 0,
    CLIENT_MESSAGE_TYPE_TOKEN_UPDATE = 1,
    UNRECOGNIZED = -1
}
export interface ServerMessage {
    timestamp: Date | undefined;
    type: ServerMessageType;
    payloadVersion: string;
    imageList?: ImageList | undefined;
    imageProcessed?: ImageProcessed | undefined;
}
export interface ClientMessage {
    timestamp: Date | undefined;
    type: ClientMessageType;
    payloadVersion: string;
    tokenUpdate?: TokenUpdate | undefined;
}




export const ServerMessageTypeDecoder = JsonDecoder.enumeration<ServerMessageType>(ServerMessageType, "ServerMessageType");

export const ClientMessageTypeDecoder = JsonDecoder.enumeration<ClientMessageType>(ClientMessageType, "ClientMessageType");

export const ServerMessageDecoder = JsonDecoder.object(
    {
		timestamp: JsonDecoder.nullable(JsonDecoder.string.map((stringDate) => { const parsedDate = new Date(stringDate); return isNaN(parsedDate.getTime()) ? null : parsedDate; })),
		type: ServerMessageTypeDecoder,
		payloadVersion: JsonDecoder.string,
		imageList: JsonDecoder.optional(ImageListDecoder),
		imageProcessed: JsonDecoder.optional(ImageProcessedDecoder),
    },
    "ServerMessage"
);

export const ClientMessageDecoder = JsonDecoder.object(
    {
		timestamp: JsonDecoder.nullable(JsonDecoder.string.map((stringDate) => { const parsedDate = new Date(stringDate); return isNaN(parsedDate.getTime()) ? null : parsedDate; })),
		type: ClientMessageTypeDecoder,
		payloadVersion: JsonDecoder.string,
		tokenUpdate: JsonDecoder.optional(TokenUpdateDecoder),
    },
    "ClientMessage"
);




